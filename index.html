<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Hand Controlled Particles</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Segoe UI', sans-serif; 
            touch-action: none;
        }
        
        #info { 
            position: absolute; 
            top: 10px; 
            width: 100%; 
            text-align: center; 
            color: rgba(255, 255, 255, 0.9); 
            pointer-events: none; 
            z-index: 10;
            text-shadow: 0 0 5px #000;
        }

        h3 { margin: 0 0 5px 0; font-size: 1.2rem; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; }
        p { margin: 2px 0; font-size: 0.85rem; }
        .highlight { color: #4facfe; font-weight: bold; }

        #video-container { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 120px; 
            height: 90px; 
            z-index: 2; 
            border: 1px solid rgba(255,255,255,0.2); 
            border-radius: 12px; 
            overflow: hidden; 
            transform: scaleX(-1); 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            background: #111;
        }
        
        video { width: 100%; height: 100%; object-fit: cover; }

        @media (max-width: 600px) {
            #video-container { width: 90px; height: 68px; bottom: 10px; right: 10px; }
            h3 { font-size: 1rem; }
            p { font-size: 0.7rem; }
        }
    </style>
</head>
<body>
    <div id="info">
        <p>‚úä <b>FIST</b>: Sphere &nbsp;|&nbsp; üñê <b>OPEN</b>: <span class="highlight">BLAST</span></p>
        <p>üëå <b>PINCH</b>: <span class="highlight">DRAG SHAPE</span></p>
        <p>‚òùÔ∏è 1: Heart | ‚úåÔ∏è 2: Saturn | ü§ü 3: Helix | üññ 4: Cube</p>
    </div>
    <div id="video-container">
        <video id="webcam" autoplay playsinline webkit-playsinline muted></video>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const IS_MOBILE = window.innerWidth < 600;
        const PARTICLE_COUNT = IS_MOBILE ? 8000 : 20000; 
        const PARTICLE_SIZE = IS_MOBILE ? 0.15 : 0.08;
        const LERP_SPEED = 0.08;
        const DRAG_SPEED = 0.15; // Smoothness of dragging

        // --- State ---
        let currentShape = 'sphere';
        let handPosition = { x: 0, y: 0 };
        let isPinching = false;
        let isBlast = false;
        let isHandDetected = false;

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 14;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- Particles ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        const colorObj = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 30;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 30;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
            
            // Initial Colors (Electric Blue/Purple)
            const hue = 0.55 + Math.random() * 0.2; 
            colorObj.setHSL(hue, 0.9, 0.6);
            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- Shape Math ---
        const shapes = {
            sphere: (i) => {
                const r = 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
            },
            heart: (i) => {
                const scale = 0.3;
                const t = Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.3); // Surface distribution
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 6; 
                return [x * scale * r, y * scale * r, z * r];
            },
            saturn: (i) => {
                const isRing = i % 100 < 70; // 70% ring
                if (!isRing) {
                    const r = 2.5;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 4 + Math.random() * 3;
                    return [Math.cos(angle) * radius, (Math.random() - 0.5) * 0.2, Math.sin(angle) * radius];
                }
            },
            helix: (i) => {
                const t = (i / PARTICLE_COUNT) * Math.PI * 12 - (Math.PI * 6);
                const r = 3;
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                const x = r * Math.cos(t + offset);
                const z = r * Math.sin(t + offset);
                const y = t * 0.7;
                return [x + (Math.random()-0.5), y + (Math.random()-0.5), z + (Math.random()-0.5)];
            },
            cube: (i) => {
                const s = 7;
                return [(Math.random()-0.5)*s, (Math.random()-0.5)*s, (Math.random()-0.5)*s];
            }
        };

        function updateTargets(shapeName) {
            const gen = shapes[shapeName];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const [x, y, z] = gen(i);
                targets[i * 3] = x;
                targets[i * 3 + 1] = y;
                targets[i * 3 + 2] = z;
            }
        }
        
        updateTargets('sphere');

        // --- Vision ---
        let handLandmarker = undefined;
        const video = document.getElementById("webcam");

        async function setupVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predict);
            });
        }

        let lastVideoTime = -1;
        async function predict() {
            if (handLandmarker && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks.length > 0) {
                    isHandDetected = true;
                    const lm = results.landmarks[0];
                    
                    // 1. Position Tracking (Center of palm roughly)
                    // Map: 0..1 to -1..1
                    const x = (lm[9].x - 0.5) * 2; 
                    const y = -(lm[9].y - 0.5) * 2;
                    handPosition = { x, y };

                    // 2. Gesture Logic
                    const tips = [8, 12, 16, 20]; 
                    const pips = [6, 10, 14, 18];
                    let fingersUp = 0;
                    tips.forEach((tip, i) => { if (lm[tip].y < lm[pips[i]].y) fingersUp++; });
                    
                    // Thumb Check (Horizontal distance)
                    if (Math.abs(lm[4].x - lm[2].x) > 0.04) fingersUp++;

                    // 3. Pinch Detection (Thumb tip + Index tip)
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    isPinching = pinchDist < 0.05; // Touching threshold

                    // 4. State Management
                    // Open Hand (5) -> Blast
                    isBlast = (fingersUp === 5);

                    // Determine Shape
                    let nextShape = currentShape;

                    // Fist (0) -> Sphere
                    if (fingersUp === 0) nextShape = 'sphere';
                    else if (fingersUp === 1) nextShape = 'heart';
                    else if (fingersUp === 2) nextShape = 'saturn';
                    else if (fingersUp === 3) nextShape = 'helix';
                    else if (fingersUp === 4) nextShape = 'cube';
                    // 5 is Blast, so we don't change base shape

                    if (nextShape !== currentShape && !isBlast) {
                        currentShape = nextShape;
                        updateTargets(currentShape);
                    }

                } else {
                    isHandDetected = false;
                    isPinching = false;
                    isBlast = false;
                }
            }
            requestAnimationFrame(predict);
        }

        setupVision();

        // --- Loop ---
        const clock = new THREE.Clock();
        const targetPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 1. Rotation Logic
            if (!isPinching) {
                // If not dragging, just rotate constantly
                particleSystem.rotation.y += 0.001;
                // And tilt slightly towards hand
                if (isHandDetected) {
                    particleSystem.rotation.x += (handPosition.y * 0.3 - particleSystem.rotation.x) * 0.05;
                    particleSystem.rotation.y += (-handPosition.x * 0.3 - particleSystem.rotation.y) * 0.05;
                }
            }

            // 2. Drag / Position Logic
            if (isPinching && isHandDetected) {
                // Drag Mode: Map hand screen coords to 3D world coords
                // At z=0, width is roughly 25 units.
                targetPos.set(handPosition.x * 12, handPosition.y * 8, 0);
            } else {
                // Release Mode: Return to center
                targetPos.set(0, 0, 0);
            }
            // Smooth move
            particleSystem.position.lerp(targetPos, DRAG_SPEED);


            // 3. Particle Updates
            const p = geometry.attributes.position.array;
            const c = geometry.attributes.color.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                let tx, ty, tz;

                if (isBlast) {
                    // Blast: explode outward from center relative to current position
                    // We simulate this by targeting a scaled version of the current shape
                    tx = targets[ix] * 6; // 6x expansion
                    ty = targets[ix+1] * 6;
                    tz = targets[ix+2] * 6;
                } else {
                    tx = targets[ix];
                    ty = targets[ix+1];
                    tz = targets[ix+2];
                }

                // Lerp current position to target
                const speed = isBlast ? 0.15 : LERP_SPEED;
                p[ix] += (tx - p[ix]) * speed;
                p[ix+1] += (ty - p[ix+1]) * speed;
                p[ix+2] += (tz - p[ix+2]) * speed;

                // Color Flash on Blast
                if (isBlast) {
                    c[ix] = 1.0;   // Red/White hot
                    c[ix+1] = 0.9;
                    c[ix+2] = 0.5;
                } else {
                    // Gradual fade back to blue/purple
                    // Target color logic (simple restoration)
                    const baseHue = 0.6; // Blue
                    c[ix] += (0.1 - c[ix]) * 0.05;
                    c[ix+1] += (0.6 - c[ix+1]) * 0.05;
                    c[ix+2] += (1.0 - c[ix+2]) * 0.05;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
